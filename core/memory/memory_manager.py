import logging
from typing import Any, Optional, Dict, List

from .memory_interface import MemoryInterface
from .short_term import InMemoryShortTermStore
from .sqlite_store import SQLiteLongTermStore # Assuming this is where SQLiteLongTermStore is

logger = logging.getLogger("Sebastian.MemoryManager")

class MemoryManager(MemoryInterface):
    """
    Manages different types of memory stores (short-term, long-term)
    and provides a unified interface for memory operations.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config if config else {}
        
        # Initialize Short-Term Store
        # Short-term store config could be nested, e.g., self.config.get('short_term_memory', {})
        self.short_term_store = InMemoryShortTermStore()
        
        # Initialize Long-Term Store
        ltm_config = self.config.get('long_term_memory', {})
        db_path = ltm_config.get('sqlite_db_path') # Example: "core/memory/data/sebastian_memory.db"
        self.long_term_store = SQLiteLongTermStore(db_path=db_path)
        
        logger.info("MemoryManager initialized with InMemoryShortTermStore and SQLiteLongTermStore.")

    async def initialize(self, config: Optional[Dict[str, Any]] = None) -> None:
        """
        Initializes the underlying memory stores, particularly the long-term store.
        The config passed here could override or supplement the one from __init__.
        """
        if config: # Allow re-configuration or late configuration
            ltm_config = config.get('long_term_memory', self.config.get('long_term_memory', {}))
            db_path = ltm_config.get('sqlite_db_path', self.long_term_store.db_path)
            if db_path != self.long_term_store.db_path: # If path changed, re-init LTM store
                 self.long_term_store = SQLiteLongTermStore(db_path=db_path)
        
        await self.long_term_store.initialize()
        # InMemoryShortTermStore typically doesn't need async initialization beyond its __init__
        logger.info("MemoryManager's underlying stores initialized.")

    # --- Short-Term Memory Methods ---
    async def add_short_term_memory(self, session_id: str, key: str, value: Any, ttl_seconds: Optional[int] = None) -> None:
        await self.short_term_store.add(session_id, key, value, ttl_seconds)

    async def get_short_term_memory(self, session_id: str, key: str) -> Optional[Any]:
        return await self.short_term_store.get(session_id, key)

    async def get_session_context(self, session_id: str) -> Dict[str, Any]:
        return await self.short_term_store.get_session_all(session_id)
    
    async def remove_short_term_memory(self, session_id: str, key: str) -> bool:
        return await self.short_term_store.remove(session_id, key)

    async def clear_short_term_session(self, session_id: str) -> None:
        await self.short_term_store.clear_session(session_id)

    # --- Long-Term Memory Methods ---
    async def store_long_term_memory(self, user_id: str, memory_type: str, data: Dict[str, Any], tags: Optional[List[str]] = None) -> str:
        # Embedding would be generated by NLPEngine or a dedicated service before calling this
        embedding = data.pop('embedding', None) # Example: if embedding is passed within data
        return await self.long_term_store.store(user_id, memory_type, data, tags, embedding)

    async def retrieve_long_term_memories(
        self, 
        user_id: str, 
        query: Optional[str] = None, 
        memory_type: Optional[str] = None, 
        tags: Optional[List[str]] = None, 
        limit: int = 5
    ) -> List[Dict[str, Any]]:
        # In a more advanced system, 'query' might be used for semantic search
        # which would involve generating an embedding for the query and comparing
        # against stored embeddings in self.long_term_store.
        return await self.long_term_store.retrieve(user_id, query, memory_type, tags, limit)

    async def get_long_term_memory_by_id(self, memory_id: str, user_id: Optional[str] = None) -> Optional[Dict[str, Any]]:
        return await self.long_term_store.get_by_id(memory_id, user_id)
    
    async def update_long_term_memory(self, memory_id: str, data_update: Dict[str, Any], user_id: Optional[str] = None) -> bool:
        # Embedding update logic would be similar to store_long_term_memory if applicable
        if 'data' in data_update and 'embedding' in data_update['data']:
            data_update['embedding'] = data_update['data'].pop('embedding')
        return await self.long_term_store.update(memory_id, data_update, user_id)

    async def delete_long_term_memory(self, memory_id: str, user_id: Optional[str] = None) -> bool:
        return await self.long_term_store.delete(memory_id, user_id)

    async def close(self) -> None:
        """Closes connections and releases resources used by the memory system."""
        logger.info("MemoryManager closing underlying stores...")
        await self.long_term_store.close()
        # InMemoryShortTermStore typically doesn't need an explicit close unless it holds external resources.
        logger.info("MemoryManager underlying stores closed.")

    async def cleanup_expired_short_term(self) -> None:
        """Actively cleans up expired short-term memories."""
        await self.short_term_store.cleanup_expired()
        logger.debug("MemoryManager invoked cleanup of expired short-term memories.")
